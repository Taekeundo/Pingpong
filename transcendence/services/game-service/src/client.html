<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ping Pong Game Client</title>
<style>
  body { background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
  canvas { background: #000; display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Scale game units to canvas
// Game coordinates: x from -50 to +50 (100 units wide), y from -100 to +100 (200 units tall)
const boardWidth = 100;   // Total width: -50 to +50
const boardHeight = 200;  // Total height: -100 to +100
const scaleX = canvas.width / boardWidth;   // 800/100 = 8 pixels per game unit
const scaleY = canvas.height / boardHeight; // 400/200 = 2 pixels per game unit

let gameState = null;

const ws = new WebSocket('ws://localhost:3002/game-ws');

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === 'STATE_UPDATE') {
    gameState = data.gameState;
    draw(); // Draw immediately on server update
  }
};

// Draw function
function draw() {
  if (!gameState) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw center line
  ctx.strokeStyle = '#555';
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(canvas.width/2, 0);
  ctx.lineTo(canvas.width/2, canvas.height);
  ctx.stroke();
  ctx.setLineDash([]);

  // Paddle settings
  const paddleHeight = 40 * scaleY;  // 40 game units * 2 pixels/unit = 80 pixels
  const paddleWidth = 2 * scaleX;    // 2 game units * 8 pixels/unit = 16 pixels
  
  // Paddle positions - place them right on the boundary lines
  const leftPaddleX = -50;   // Left boundary 
  const rightPaddleX = 50;   // Right boundary
  
  // Convert game coordinates to canvas coordinates and adjust for paddle width
  const paddleXLeft = (leftPaddleX + 50) * scaleX;           // Left edge of canvas (0)
  const paddleXRight = (rightPaddleX + 50) * scaleX - paddleWidth; // Right edge minus paddle width

  // Left paddle (player1)
  const paddleY1 = canvas.height/2 - gameState.paddles.player1 * scaleY - paddleHeight/2;
  ctx.fillStyle = 'white';
  ctx.fillRect(paddleXLeft, paddleY1, paddleWidth, paddleHeight);

  // Right paddle (player2)
  const paddleY2 = canvas.height/2 - gameState.paddles.player2 * scaleY - paddleHeight/2;
  ctx.fillStyle = 'white';
  ctx.fillRect(paddleXRight, paddleY2, paddleWidth, paddleHeight);

  // Ball - use server data directly at 60 FPS
  const ballRadius = 2 * scaleY;
  const ballX = canvas.width/2 + gameState.ball.x * scaleX;
  const ballY = canvas.height/2 - gameState.ball.y * scaleY;
  ctx.beginPath();
  ctx.arc(ballX, ballY, ballRadius, 0, Math.PI*2);
  ctx.fillStyle = 'red';
  ctx.fill();

  // Scores and Tournament Info
  ctx.fillStyle = 'white';
  ctx.font = '20px Arial';
  ctx.fillText(gameState.score.player1, canvas.width/4, 30);
  ctx.fillText(gameState.score.player2, 3*canvas.width/4, 30);
  
  // Round information
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.fillText(`Round ${gameState.tournament.currentRound}/${gameState.tournament.maxRounds}`, canvas.width/2 - 40, 30);
  
  // Rounds won
  ctx.font = '14px Arial';
  ctx.fillText(`Rounds: ${gameState.tournament.roundsWon.player1}`, canvas.width/4 - 30, 50);
  ctx.fillText(`Rounds: ${gameState.tournament.roundsWon.player2}`, 3*canvas.width/4 - 30, 50);
  
  // Player labels at the bottom of the screen
  ctx.fillStyle = 'lightblue';
  ctx.font = '14px Arial';
  ctx.fillText('Player 1', canvas.width/4 - 30, canvas.height - 30);
  ctx.fillStyle = 'white';
  ctx.font = '10px Arial';
  ctx.fillText('(WASD)', canvas.width/4 - 25, canvas.height - 15);
  
  ctx.fillStyle = 'lightgreen';
  ctx.font = '14px Arial';
  ctx.fillText('Player 2', 3*canvas.width/4 - 30, canvas.height - 30);
  ctx.fillStyle = 'white';
  ctx.font = '10px Arial';
  ctx.fillText('(Arrows)', 3*canvas.width/4 - 25, canvas.height - 15);
  
  // Game status
  if (gameState.tournament.gameStatus === 'waiting') {
    ctx.font = '24px Arial';
    ctx.fillStyle = 'yellow';
    ctx.fillText('Press SPACE to Start Game', canvas.width/2 - 120, canvas.height/2);
  } else if (gameState.tournament.gameStatus === 'roundEnd') {
    ctx.font = '24px Arial';
    ctx.fillStyle = 'yellow';
    ctx.fillText('Round End!', canvas.width/2 - 60, canvas.height/2 - 50);
    ctx.font = '18px Arial';
    ctx.fillText(`Next round starting in 3 seconds...`, canvas.width/2 - 100, canvas.height/2 - 20);
    ctx.fillText(`Starting Round ${gameState.tournament.currentRound + 1}`, canvas.width/2 - 80, canvas.height/2 + 10);
  } else if (gameState.tournament.gameStatus === 'gameEnd') {
    ctx.font = '32px Arial';
    ctx.fillStyle = 'gold';
    const winner = gameState.tournament.winner === 'player1' ? 'Player 1' : 'Player 2';
    ctx.fillText(`${winner} Wins!`, canvas.width/2 - 100, canvas.height/2);
    ctx.font = '18px Arial';
    ctx.fillStyle = 'white';
    ctx.fillText('Game Over', canvas.width/2 - 50, canvas.height/2 + 30);
    ctx.fillText('Press R to restart', canvas.width/2 - 70, canvas.height/2 + 60);
  }
}

// Paddle control - both players
document.addEventListener('keydown', (e) => {
  let player = null;
  let direction = 0;
  
  // Start game/round
  if (e.key === ' ') { // Space bar
    if (gameState.tournament.gameStatus === 'waiting') {
      ws.send(JSON.stringify({ type: 'START_GAME' }));
    }
    return;
  }
  
  // Restart game
  if (e.key === 'r' || e.key === 'R') {
    ws.send(JSON.stringify({ type: 'RESTART_GAME' }));
    return;
  }
  
  // Player 1 controls (WASD)
  if (e.key === 'w' || e.key === 'W') {
    player = 'player1';
    direction = 'up';
  }
  if (e.key === 's' || e.key === 'S') {
    player = 'player1';
    direction = 'down';
  }
  
  // Player 2 controls (Arrow keys)
  if (e.key === 'ArrowUp') {
    player = 'player2';
    direction = 'up';
  }
  if (e.key === 'ArrowDown') {
    player = 'player2';
    direction = 'down';
  }
  
  // Send movement command
  if (player && direction) {
    ws.send(JSON.stringify({ type: 'MOVE_PADDLE', player, direction }));
  }
});

</script>
</body>
</html>
